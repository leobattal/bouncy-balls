<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Bouncy Ball Sandbox</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #111;
    touch-action: none;
  }

  canvas {
    display: block;
  }

  /* --- SETTINGS UI --- */
  #settingsBtn {
    position: fixed;
    top: 12px;
    right: 12px;
    width: 44px;
    height: 44px;
    border-radius: 50%;
    border: none;
    font-size: 22px;
    background: #222;
    color: white;
    z-index: 10;
  }

  #settingsPanel {
    position: fixed;
    top: 0;
    right: 0;
    width: min(300px, 80vw);
    height: 100vh;
    background: #1a1a1a;
    color: white;
    padding: 20px;
    box-sizing: border-box;
    transform: translateX(100%);
    transition: transform 0.3s ease;
    z-index: 20;
    overflow-y: auto;
  }

  #settingsPanel.open {
    transform: translateX(0);
  }

  #settingsPanel h2 {
    margin-top: 0;
  }

  #settingsPanel label {
    display: block;
    margin: 20px 0;
  }

  #settingsPanel input {
    width: 100%;
  }

  #closeSettings, #clearBalls, #resetDefaults {
    margin-top: 20px;
    width: 100%;
  }
</style>
</head>
<body>
  <button id="settingsBtn">⚙️</button>

  <div id="settingsPanel">
    <h2>Settings</h2>

    <label>
      Gravity
      <input type="range" id="gravitySlider" min="0" max="2" step="0.05">
    </label>

    <label>
      Bounce
      <input type="range" id="bounceSlider" min="0" max="1" step="0.05">
    </label>

    <label>
      Max Ball Size
      <input type="range" id="maxSizeSlider" min="10" max="200" step="5">
    </label>

    <button id="clearBalls">Clear All Balls</button>
    <button id="resetDefaults">Reset Defaults</button>
    <button id="closeSettings">Close</button>
  </div>

  <canvas id="canvas"></canvas>

<script>
const settingsBtn = document.getElementById("settingsBtn");
const settingsPanel = document.getElementById("settingsPanel");
const closeSettings = document.getElementById("closeSettings");

const gravitySlider = document.getElementById("gravitySlider");
const bounceSlider = document.getElementById("bounceSlider");
const maxSizeSlider = document.getElementById("maxSizeSlider");
const clearBalls = document.getElementById("clearBalls");
const resetDefaults = document.getElementById("resetDefaults");

let gravity = 0.6;
let bounce = 0.85;
let maxBallSize = 150;

let growing = false;
let growRadius = 5;
let growX = 0;
let growY = 0;

let draggingBall = null;
let dragOffsetX = 0;
let dragOffsetY = 0;

const balls = [];

// --- Initialize sliders ---
gravitySlider.value = gravity;
bounceSlider.value = bounce;
maxSizeSlider.value = maxBallSize;

// --- Settings button events ---
settingsBtn.onclick = () => {
  settingsPanel.classList.add("open");
};

closeSettings.onclick = () => {
  settingsPanel.classList.remove("open");
};

gravitySlider.oninput = () => {
  gravity = parseFloat(gravitySlider.value);
};

bounceSlider.oninput = () => {
  bounce = parseFloat(bounceSlider.value);
};

maxSizeSlider.oninput = () => {
  maxBallSize = parseInt(maxSizeSlider.value);
};

clearBalls.onclick = () => {
  balls.length = 0;
};

resetDefaults.onclick = () => {
  gravity = 0.6;
  bounce = 0.85;
  maxBallSize = 150;

  gravitySlider.value = gravity;
  bounceSlider.value = bounce;
  maxSizeSlider.value = maxBallSize;
};

// --- Canvas setup ---
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

// --- Utility: get ball under cursor ---
function getBallAt(x, y) {
  for (let i = balls.length - 1; i >= 0; i--) {
    const b = balls[i];
    const dx = x - b.x;
    const dy = y - b.y;
    if (Math.hypot(dx, dy) <= b.r) return b;
  }
  return null;
}

// --- Collision resolver ---
function resolveCollision(a, b) {
  const dx = b.x - a.x;
  const dy = b.y - a.y;
  const dist = Math.hypot(dx, dy);

  const minDist = a.r + b.r;
  if (dist === 0 || dist >= minDist) return;

  const overlap = minDist - dist;
  const nx = dx / dist;
  const ny = dy / dist;

  a.x -= nx * overlap * 0.5;
  a.y -= ny * overlap * 0.5;
  b.x += nx * overlap * 0.5;
  b.y += ny * overlap * 0.5;

  const m1 = a.r * a.r;
  const m2 = b.r * b.r;

  const rvx = b.vx - a.vx;
  const rvy = b.vy - a.vy;

  const velAlongNormal = rvx * nx + rvy * ny;
  if (velAlongNormal > 0) return;

  const restitution = 0.85;
  const impulse =
    (-(1 + restitution) * velAlongNormal) /
    (1 / m1 + 1 / m2);

  const ix = impulse * nx;
  const iy = impulse * ny;

  a.vx -= ix / m1;
  a.vy -= iy / m1;
  b.vx += ix / m2;
  b.vy += iy / m2;
}

// ---- INPUT HANDLERS ----

// --- MOUSE ---
canvas.addEventListener("mousedown", e => {
  const b = getBallAt(e.clientX, e.clientY);
  if (b) {
    draggingBall = b;
    dragOffsetX = e.clientX - b.x;
    dragOffsetY = e.clientY - b.y;
  } else {
    growing = true;
    growRadius = 5;
    growX = e.clientX;
    growY = e.clientY;
  }
});

canvas.addEventListener("mousemove", e => {
  if (draggingBall) {
    draggingBall.x = e.clientX - dragOffsetX;
    draggingBall.y = e.clientY - dragOffsetY;
    draggingBall.vx = 0;
    draggingBall.vy = 0;
  } else if (growing) {
    growX = e.clientX;
    growY = e.clientY;
  }
});

canvas.addEventListener("mouseup", () => {
  draggingBall = null;
  if (!growing) return;

  balls.push({
    x: growX,
    y: growY,
    r: growRadius,
    vx: (Math.random() - 0.5) * 4,
    vy: 0,
    color: `hsl(${Math.random() * 360}, 80%, 60%)`
  });

  growing = false;
});

// --- TOUCH ---
canvas.addEventListener("touchstart", e => {
  e.preventDefault();
  const t = e.touches[0];
  const b = getBallAt(t.clientX, t.clientY);
  if (b) {
    draggingBall = b;
    dragOffsetX = t.clientX - b.x;
    dragOffsetY = t.clientY - b.y;
  } else {
    growing = true;
    growRadius = 5;
    growX = t.clientX;
    growY = t.clientY;
  }
});

canvas.addEventListener("touchmove", e => {
  if (!e.touches.length) return;
  const t = e.touches[0];
  if (draggingBall) {
    draggingBall.x = t.clientX - dragOffsetX;
    draggingBall.y = t.clientY - dragOffsetY;
    draggingBall.vx = 0;
    draggingBall.vy = 0;
  } else if (growing) {
    growX = t.clientX;
    growY = t.clientY;
  }
});

canvas.addEventListener("touchend", e => {
  e.preventDefault();
  draggingBall = null;

  if (!growing) return;

  balls.push({
    x: growX,
    y: growY,
    r: growRadius,
    vx: (Math.random() - 0.5) * 4,
    vy: 0,
    color: `hsl(${Math.random() * 360}, 80%, 60%)`
  });
  growing = false;
});

// ---- GAME LOOP ----
function loop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Ball collisions
  for (let i = 0; i < balls.length; i++) {
    for (let j = i + 1; j < balls.length; j++) {
      resolveCollision(balls[i], balls[j]);
    }
  }

  // Ball physics & drawing
  for (const ball of balls) {
    if (ball !== draggingBall) {
      ball.vy += gravity;
      ball.x += ball.vx;
      ball.y += ball.vy;

      if (ball.y + ball.r > canvas.height) {
        ball.y = canvas.height - ball.r;
        ball.vy *= -bounce;
      }

      if (ball.x - ball.r < 0 || ball.x + ball.r > canvas.width) {
        ball.vx *= -bounce;
      }
    }

    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
    ctx.fillStyle = ball.color;
    ctx.fill();
  }

  // Growing ball outline
  if (growing) {
    growRadius += 0.6;
    if (growRadius > maxBallSize) growRadius = maxBallSize;
    ctx.beginPath();
    ctx.arc(growX, growY, growRadius, 0, Math.PI * 2);
    ctx.strokeStyle = "white";
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
